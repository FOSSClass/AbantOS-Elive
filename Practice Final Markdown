---
Title: "Final Project"
Instructor: Matthew
Date: 2017-12-06
Subject: "CSCI 2461-70 Fall 2017"
Tags: [Attendance, Journal-Week, UNIX-History, AbantOS]

...

# Attendance

These are my following attendance for this session:

1. 08/30/2017
2. 09/09/2017
3. 09/13/2017
4. 09/20/2017
5. 09/27/2017
6. 10/04/2017
7. 10/11/2017
8. 10/18/2017
9. 10/25/2017
10. 11/1/2017
11. 11/8/2017
12. 11/15/2017
13. 11/29/2017
14. 12/06/2017

## Journal-Week

## * Journal-Week 1 *

How do I learn from Chapter 1: The Big Picture. Unit 1.1 Levels and Layers of Abraction in a Linux System. A layer or level is a classification of component 
that sites between the user and hardware. A Linux system has three main levels. These are hardware, kernel, and processes. Of sometimes called user space. 
The hardware is at the base. It includes processor (CPU), main memory (RAM), disks, and network ports. The next level up is kernel, which is the core of the 
operating system. The kernel is software that telling the CPU what to do. Inside the kernel, it contains system calls process management, memory management, 
and device drivers. The kernel also is the primary managing between the hardware and any running program. The upper level is processes and it is the one 
the kernel manages. Processes is the way user directly interacts with. There is a critical difference between the kernel and user process run. The kernel runs 
in kernel mode and the user processes run in user mode. Code running in kernel mode has unrestricted access the processor and main memory. 
This is a powerful tool, but it can easily crash the entire system. User mode restrict access to a subset of memory and safe CPU operation. 
Unit 1.2 Hardware: Understanding Main Memory. I learn that main memory is the most important part the hardware on the computer. Main memory is a bunch area 
for 0s and 1s. 0s and 1s refers as a bit. All input and output from devices flow through main memory, also as a bunch of bits. Unit 1.3 The Kernel. 
I learn that the kernel is in charge of managing tasks in four general system areas. These areas are Processes, Memory, Device drivers, and System calls/Support.
The duty of each of them as follow. Processes is the way the kernel is responsible for determining which processes are allow to use the CPU. Memory is the way 
the kernel determines what can be shared between process, and what is free. Drive drivers is the kernel acts as an interface between the hardware disk and 
processes. System calls and support is the processes uses to communicate with the kernel. Unit 1.3.1 Process Management. From my understanding, 
process management describes the starting, pausing, resuming, and terminating or processes. Many processes may be able to use the CPU, but only one process may 
actually use the CPU at any given time. For example, each process uses the CPU for a small fraction of a second, then pauses, then another process takes a turn 
and so on. Unit 1.3.2 Memory Management. I learn that the kernel has to manage the memory during a context switch, which it has a difficult job of memory 
management. These tasks perform as the following. The kernel must has its own private area in memory that the user cannot access. Each user process needs 
its own section of memory. One user process may not access the private memory of another process. User processes can share memory. Come memory in user processes 
can be read-only. However, the system can use more memory than is physically present by using disk space as auxiliary. Unit 1.3.3 Device Drivers and 
Management. I learn that a device is typically accessible only in kernel mode because improver access could crash the machine. Therefore, devices have 
traditionally been part of the kernel, and they strive to present a uniform interface to user process in order to simplify the software developer’s job. 
Unit 1.3.4 System Calls and Support. I learn that system calls perform specific tasks that user process alone cannot do well or at all. Fork () and exec () are 
the two system calls. Fork () is when a process calls fork (), the kernel creates a nearly identical copy of the process. Exec () is when a process calls 
exec (program), the kernel starts program, replacing the current process. Therefore, all users processes on Linux system start as a result of fork (), exec () 
to start new program. Unit 1.4 User Space. I learn that user space refers to the memory for the entire collection of running processes. There is a rudimentary 
service level or layer structure that the user processes represent. The bottom level tends to consist of small components that perform single uncomplicated 
tasks. The middle level has larger components such as mail, print, and database services. Finally, components at the top level perform complicated tasks that 
the user often controls directly. Unit 1.5 Users. I learn that a user is an entity that can process and own files. A user is associated with a username. 
A username can be named as billyjoe. Therefore, every user-space has a user own and runs as the owner. A user can modify of its own process, but it cannot 
mess up or interfere with other’s user processes. The following commands are the one that we learned from journal week 1: * cat* command outputs the contents of one or more files.
ls command lists the contents of a directory. cp command uses to copy files. mv command is similar as cp but it can renames a file. touch command uses to create a file.
rm command uses to delete or a remove a file. echo command prints its arguments to the standard output. cd command changes the shell’s current working directory.

## * Journal-Week 2 *
